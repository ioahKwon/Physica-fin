#!/usr/bin/env python3
"""
Apply force visualization to refined SKEL skeleton meshes.

Reads AddBiomechanics data for torque information and applies it to
refined skeleton meshes generated by torso finetuning.

Usage:
    python -m skel_force_vis.apply_force_to_refined \
        --b3d /path/to/subject.b3d \
        --skeleton-dir /path/to/skel_refined \
        --output /path/to/output
"""

import os
import sys
import argparse
import json
import numpy as np
from typing import Dict, List, Optional

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, '/egr/research-zijunlab/kwonjoon/01_Code/Physica/AddB_to_SMPL')

from skel_force_vis.colormaps import torque_to_color_plasma, AXIS_COLORS
from skel_force_vis.mesh_utils import (
    create_line_mesh,
    create_sphere_mesh,
    read_obj_mesh,
)

# AddBiomechanics joint DOF mapping
JOINT_DOF_MAP = {
    'ground_pelvis': (0, 6),
    'hip_r': (6, 3),
    'walker_knee_r': (9, 1),
    'ankle_r': (10, 1),
    'subtalar_r': (11, 1),
    'mtp_r': (12, 1),
    'hip_l': (13, 3),
    'walker_knee_l': (16, 1),
    'ankle_l': (17, 1),
    'subtalar_l': (18, 1),
    'mtp_l': (19, 1),
    'back': (20, 3),
    'acromial_r': (23, 3),
    'elbow_r': (26, 1),
    'radioulnar_r': (27, 1),
    'radius_hand_r': (28, 2),
    'acromial_l': (30, 3),
    'elbow_l': (33, 1),
    'radioulnar_l': (34, 1),
    'radius_hand_l': (35, 2),
}


class ForceVisualizer:
    """Apply force visualization to refined SKEL meshes."""

    def __init__(
        self,
        max_torque: float = 300.0,
        line_scale: float = 0.002,
        line_radius: float = 0.004,
        sphere_radius: float = 0.012,
        torque_threshold: float = 0.5,
    ):
        self.max_torque = max_torque
        self.line_scale = line_scale
        self.line_radius = line_radius
        self.sphere_radius = sphere_radius
        self.torque_threshold = torque_threshold
        self.colormap = torque_to_color_plasma
        self.axis_colors = AXIS_COLORS

    def load_addb_data(self, b3d_path: str, trial_idx: int = 0) -> Dict:
        """Load AddBiomechanics data from .b3d file."""
        try:
            import nimblephysics as nimble
        except ImportError:
            print("Error: nimblephysics not available")
            return {}

        subject = nimble.biomechanics.SubjectOnDisk(b3d_path)
        skel = subject.readSkel(0, ignoreGeometry=True)

        num_frames = subject.getTrialLength(trial_idx)
        print(f"Loaded {b3d_path}: trial {trial_idx}, {num_frames} frames")

        # Get joint names
        joint_names = [skel.getJoint(i).getName() for i in range(skel.getNumJoints())]

        # Extract data for each frame
        frames_data = []
        for frame_idx in range(num_frames):
            frame = subject.readFrames(trial_idx, frame_idx, 1)[0]

            # Use the last processing pass (dynamics fitted)
            pp = frame.processingPasses[-1]
            pos = pp.pos  # Joint positions (DOF)
            tau = pp.tau  # Joint torques

            skel.setPositions(pos)

            # Get body positions
            body_positions = {}
            for i in range(skel.getNumBodyNodes()):
                body = skel.getBodyNode(i)
                transform = body.getWorldTransform()
                body_positions[body.getName()] = np.array(transform.translation())

            # Get joint positions and torques
            joint_data = []
            for joint_name, (dof_start, dof_count) in JOINT_DOF_MAP.items():
                if dof_start + dof_count <= len(tau):
                    tau_slice = tau[dof_start:dof_start + dof_count]
                    magnitude = np.linalg.norm(tau_slice)

                    # Find corresponding body position
                    body_name = self._joint_to_body(joint_name)
                    if body_name in body_positions:
                        position = body_positions[body_name]
                    else:
                        position = np.zeros(3)

                    joint_data.append({
                        'joint': joint_name,
                        'position': position.tolist(),
                        'tau': tau_slice.tolist(),
                        'magnitude': float(magnitude),
                    })

            frames_data.append({
                'frame_idx': frame_idx,
                'joint_torques': joint_data,
            })

        return {
            'num_frames': num_frames,
            'joint_names': joint_names,
            'frames': frames_data,
        }

    def _joint_to_body(self, joint_name: str) -> str:
        """Map joint name to body name in AddBiomechanics skeleton."""
        mapping = {
            'ground_pelvis': 'pelvis',
            'hip_r': 'femur_r',
            'walker_knee_r': 'tibia_r',
            'ankle_r': 'talus_r',
            'subtalar_r': 'calcn_r',
            'mtp_r': 'toes_r',
            'hip_l': 'femur_l',
            'walker_knee_l': 'tibia_l',
            'ankle_l': 'talus_l',
            'subtalar_l': 'calcn_l',
            'mtp_l': 'toes_l',
            'back': 'torso',
            'acromial_r': 'humerus_r',
            'elbow_r': 'ulna_r',
            'radioulnar_r': 'radius_r',
            'radius_hand_r': 'hand_r',
            'acromial_l': 'humerus_l',
            'elbow_l': 'ulna_l',
            'radioulnar_l': 'radius_l',
            'radius_hand_l': 'hand_l',
        }
        return mapping.get(joint_name, joint_name)

    def process_frame(
        self,
        skeleton_obj_path: str,
        frame_data: Dict,
        output_path: str,
    ) -> bool:
        """
        Process a single frame.

        Args:
            skeleton_obj_path: Path to refined skeleton OBJ
            frame_data: Frame data with joint_torques
            output_path: Output OBJ path

        Returns:
            True if successful
        """
        if not os.path.exists(skeleton_obj_path):
            return False

        # Read skeleton mesh
        skeleton_vertices, skeleton_faces = read_obj_mesh(skeleton_obj_path)

        # Build joint dictionaries
        joint_positions = {}
        joint_torques = {}
        joint_tau_vectors = {}

        for jt in frame_data.get('joint_torques', []):
            joint_name = jt['joint']
            joint_positions[joint_name] = np.array(jt['position'])
            joint_torques[joint_name] = jt['magnitude']
            joint_tau_vectors[joint_name] = np.array(jt['tau'])

        # Compute vertex colors
        vertex_colors = self._compute_vertex_colors(
            skeleton_vertices, joint_positions, joint_torques
        )

        # Create axis lines
        lines_data = self._create_axis_lines(
            joint_positions, joint_tau_vectors
        )

        # Write combined OBJ
        self._write_combined_obj(
            output_path, skeleton_vertices, skeleton_faces,
            vertex_colors, lines_data
        )

        return True

    def _compute_vertex_colors(
        self,
        vertices: np.ndarray,
        joint_positions: Dict[str, np.ndarray],
        joint_torques: Dict[str, float]
    ) -> List[tuple]:
        """Compute vertex colors based on nearest joint torque."""
        if len(joint_positions) == 0:
            return [(0.8, 0.8, 0.8)] * len(vertices)

        joint_names = list(joint_positions.keys())
        joint_pos_array = np.array([joint_positions[name] for name in joint_names])

        colors = []
        for vertex in vertices:
            distances = np.linalg.norm(joint_pos_array - vertex, axis=1)
            nearest_idx = np.argmin(distances)
            nearest_joint = joint_names[nearest_idx]
            torque_mag = joint_torques.get(nearest_joint, 0)
            color = self.colormap(torque_mag, self.max_torque)
            colors.append(color)

        return colors

    def _create_axis_lines(
        self,
        joint_positions: Dict[str, np.ndarray],
        joint_tau_vectors: Dict[str, np.ndarray]
    ) -> List[tuple]:
        """Create 3-axis lines with endpoint spheres."""
        lines_data = []

        axes_colors = [
            self.axis_colors['x'],
            self.axis_colors['y'],
            self.axis_colors['z'],
        ]

        axes_directions = [
            np.array([1.0, 0.0, 0.0]),
            np.array([0.0, 1.0, 0.0]),
            np.array([0.0, 0.0, 1.0]),
        ]

        for joint_name, pos in joint_positions.items():
            tau_vec = joint_tau_vectors.get(joint_name, np.array([]))

            if len(tau_vec) < 1:
                continue

            # Ensure 3D vector
            if len(tau_vec) == 1:
                tau_3d = np.array([0, tau_vec[0], 0])
            elif len(tau_vec) == 2:
                tau_3d = np.array([tau_vec[0], tau_vec[1], 0])
            else:
                tau_3d = tau_vec[:3]

            for axis_idx in range(3):
                component_magnitude = abs(tau_3d[axis_idx])

                if component_magnitude < self.torque_threshold:
                    continue

                line_length = component_magnitude * self.line_scale
                direction = axes_directions[axis_idx] if tau_3d[axis_idx] > 0 else -axes_directions[axis_idx]
                end_pos = pos + direction * line_length

                # Create line cylinder
                line_verts, line_faces = create_line_mesh(
                    start=pos,
                    end=end_pos,
                    radius=self.line_radius,
                    segments=6
                )

                if len(line_verts) > 0:
                    lines_data.append((line_verts, line_faces, axes_colors[axis_idx]))

                # Create endpoint sphere
                sphere_verts, sphere_faces = create_sphere_mesh(
                    center=end_pos,
                    radius=self.sphere_radius,
                    segments=8,
                    rings=6
                )

                if len(sphere_verts) > 0:
                    lines_data.append((sphere_verts, sphere_faces, axes_colors[axis_idx]))

        return lines_data

    def _write_combined_obj(
        self,
        filepath: str,
        skeleton_vertices: np.ndarray,
        skeleton_faces: np.ndarray,
        skeleton_colors: List[tuple],
        lines_data: List[tuple]
    ) -> None:
        """Write combined skeleton + axes OBJ file."""
        with open(filepath, 'w') as f:
            f.write("# Refined SKEL skeleton + 3-axis torque lines\n")
            f.write("# Skeleton: colored by joint torque (plasma colormap)\n")
            f.write("# Axes: X=Pink, Y=Neon Green, Z=Cyan (with endpoint balls)\n\n")

            vertex_offset = 0

            # Write skeleton vertices
            for i, v in enumerate(skeleton_vertices):
                c = skeleton_colors[i]
                f.write(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f} {c[0]:.4f} {c[1]:.4f} {c[2]:.4f}\n")

            # Write skeleton faces
            for face in skeleton_faces:
                f.write(f"f {face[0]+1} {face[1]+1} {face[2]+1}\n")

            vertex_offset = len(skeleton_vertices)

            # Write axis lines and spheres
            for line_verts, line_faces, line_color in lines_data:
                if len(line_verts) == 0:
                    continue

                for v in line_verts:
                    f.write(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f} {line_color[0]:.4f} {line_color[1]:.4f} {line_color[2]:.4f}\n")

                for face in line_faces:
                    f.write(f"f {face[0]+1+vertex_offset} {face[1]+1+vertex_offset} {face[2]+1+vertex_offset}\n")

                vertex_offset += len(line_verts)


def main():
    parser = argparse.ArgumentParser(description="Apply force visualization to refined SKEL meshes")
    parser.add_argument("--b3d", required=True, help="Path to AddBiomechanics .b3d file")
    parser.add_argument("--skeleton-dir", required=True, help="Directory with refined skeleton OBJs")
    parser.add_argument("--output", required=True, help="Output directory")
    parser.add_argument("--max-torque", type=float, default=300.0, help="Max torque for colormap")
    parser.add_argument("--line-scale", type=float, default=0.002, help="Line scale (m/Nm)")
    parser.add_argument("--sphere-radius", type=float, default=0.012, help="Endpoint sphere radius")
    parser.add_argument("--prefix", default="refined_skeleton", help="Skeleton file prefix")

    args = parser.parse_args()

    os.makedirs(args.output, exist_ok=True)

    # Create visualizer
    vis = ForceVisualizer(
        max_torque=args.max_torque,
        line_scale=args.line_scale,
        sphere_radius=args.sphere_radius,
    )

    # Load AddBiomechanics data
    print(f"Loading AddBiomechanics data from {args.b3d}")
    addb_data = vis.load_addb_data(args.b3d)

    if not addb_data:
        print("Failed to load AddBiomechanics data")
        return

    num_frames = addb_data['num_frames']
    print(f"Processing {num_frames} frames...")

    success_count = 0
    for i, frame_data in enumerate(addb_data['frames']):
        skeleton_path = os.path.join(args.skeleton_dir, f"{args.prefix}_{i:04d}.obj")
        output_path = os.path.join(args.output, f"frame_{i:04d}_skeleton_axes.obj")

        if vis.process_frame(skeleton_path, frame_data, output_path):
            success_count += 1

        if (i + 1) % 50 == 0:
            print(f"  Processed {i+1}/{num_frames} frames")

    print(f"\nDone! Processed {success_count}/{num_frames} frames")
    print(f"Output: {args.output}")


if __name__ == "__main__":
    main()
